/* Thinfinity(c) Remote Desktop Server v7.0.3.114 */
// =============================================================================================================================
// Copyright 2023, CybeleSoft
// CYBELESOFT
// info@cybelesoft.com
// -- 20230915.1
// =============================================================================================================================
// =============================================================================================================================

// *****************************************************************************************************************************
// THINFINITY AUDIO PROCESSOR WORKLET CLASS ************************************************************************************
// *****************************************************************************************************************************
// *****************************************************************************************************************************
// *****************************************************************************************************************************
// -- IMPORTANT!!!
// -- Audio Worklet are only available in a secure context, thus a page using them must be served over HTTPS
// *****************************************************************************************************************************
// *****************************************************************************************************************************
class AudioProcessor extends AudioWorkletProcessor {
    #queue = [];
    #registerCmds = {};
    #bufferSize = 128;
    #lastBuffOffset = 0;
    #tDuration = 0;
    #packetBuffer = 150; // -- Each "packet" of 128 Bytes represent 2.833ms of audio, (150 packets are like 125ms of buffer)
    #reached = false;
    #lastPacketTime = 0;
    #maxTimeBeforeProcess = 750; // (ms)

    #push(item) {
        this.#queue.push(item);
        this.#tDuration += item.duration;
        if (this.#queue.length > this.#packetBuffer) {
            this.#reached = true;
        }
    }
    #pop() {
        if (this.#queue.length == 0) {
            this.#reached = false;
            return undefined;
        }
        let dnow = Date.now();
        if ((dnow - this.#lastPacketTime) > this.#maxTimeBeforeProcess) this.#reached = true;
        if (!this.#reached) return undefined;
        this.#lastPacketTime = dnow;
        var item = this.#queue.shift();
        this.#tDuration -= item.duration;
        return item;
    }
    #stripBuffer(data) {
        let chanData;
        let actualOffset = 0;
        this.#lastPacketTime = Date.now();
        // if the last buffer appended has few data than actualy needed, we complete it
        if ((this.#queue.length > 0) && (this.#lastBuffOffset != this.#bufferSize) && (!!this.#lastBuffOffset)) {
            var lastBuf = this.#queue[this.#queue.length - 1];
            var pending = this.#bufferSize - this.#lastBuffOffset;
            for (var i = 0; i < data.numberOfChannels; i++) {
                chanData = data.channelData[i];
                lastBuf.data[i] = [].concat(lastBuf.data[i].subarray(0, this.#bufferSize - pending), chanData.subarray(0, pending));
                chanData = null;
            }
            lastBuf.chuncked = true;
            lastBuf.duration += data.duration;
            this.#tDuration += data.duration;
            actualOffset += pending;
            this.#lastBuffOffset += pending;
        }
        while (actualOffset < data.len) {
            var dataSize = data.len - actualOffset >= this.#bufferSize ? this.#bufferSize : data.len - actualOffset;
            var values = new Array();
            for (var e = 0; e < data.numberOfChannels; e++) {
                chanData = data.channelData[e];
                values[e] = chanData.subarray(actualOffset, actualOffset + dataSize);
                chanData = null;
            }
            actualOffset += dataSize;

            this.#lastBuffOffset = dataSize;
            this.#push({ packetIndex: data.packetIndex, duration: data.duration, data: values });
        }
        return true;
    }
    process(inputs, outputs, parameters) {
        let values = this.#pop();
        if (values == undefined || values.data.length == 0) {
            this.#tDuration = 0;
        } else {
            // The processor may have multiple inputs and outputs. Get the first input and output.
            outputs.forEach((output, chnIdx) => {
                output.forEach((channel) => {
                    if (values.chuncked) {
                        let chnData = values.data[chnIdx];
                        let l = chnData.length;
                        let offset = 0;
                        for (let i = 0; i < l; i++) {
                            channel.set(chnData[i], offset);
                            offset += chnData[i].length;
                        }
                    } else channel.set(values.data[chnIdx]);
                });
            });
            this.port.postMessage({ packetIndex: values.packetIndex, duration: Math.round(this.#tDuration * 100) / 100 });
        }
        // To keep this processor alive.
        return true;
    }
    constructor(options) {
        super();
        this.#bufferSize = options?.processorOptions?.bufferSize ?? this.#bufferSize;
        this.#registerCmds["stripBuffer"] = this.#stripBuffer;
        this.port.onmessage = (event) => {
            // Handling data from the node.
            if (event.data && this.#registerCmds[event.data.cmd]) this.#registerCmds["stripBuffer"].apply(this, [event.data.data]);
        };
    }
}
registerProcessor("audio-worklet-processor.js", AudioProcessor);
// *****************************************************************************************************************************
// END THINFINITY AUDIO PROCESSOR WORKLET CLASS ********************************************************************************
// *****************************************************************************************************************************